## Models for Population Growth
人口增长的一个模型基于以下假设：人口的增长速度与人口规模成正比。(ideal conditions)
设：
t − 时间 s （ x ）
P − 人口中的个体 （y）

人口增长率：![](images/Pasted%20image%2020240913080033.png)
因为上述的假设，所以有方程（1）：
![](images/Pasted%20image%2020240913080123.png)
k 为比例常数。这是一个微分方程，因为里面包括了一个未知函数 P 和它的导数

对于函数 P(t)，增长率随着人口的增加而增加

如何求解？方程（1）要求我们找到一个函数，其导数是自身的常数倍数，而指数函数（取 e 为底是为了方便计算）具有这个性质。事实上，令![](images/Pasted%20image%2020240913080949.png)，则有：
![](images/Pasted%20image%2020240913080959.png)

因此形如![](images/Pasted%20image%2020240913081126.png)
的指数函数都是方程（1）的解。

变量 C 变化得到一系列解，这些解的图形如图 1 所示
![](images/Pasted%20image%2020240913080544.png)
然而，实际的人口规模应该是大于零的，所以只关注那些 C>0 的解。
![](images/Pasted%20image%2020240913081848.png)

为了更准确地模拟实际情况，需要考虑两种趋势：一是初始阶段的增长率与种群规模成正比；二是当种群规模超过一定阈值 M 后，种群开始下降。

- ![](images/Pasted%20image%2020240913082032.png)
P 很小（最初，增长率与 P 成正比）
- ![](images/Pasted%20image%2020240913082120.png)
P > M（如果 P 超过 M，则 P 会降低。）

包含这两个假设的简单表达式由方程（2）（称之为：逻辑斯谛微分方程）给出
![](images/Pasted%20image%2020240913082345.png)
条件 1，括号里出来的是整数；条件 2，出来的是负数。

现在可以从方程推出解：P (t)=0，和 P (t)=M。在这两种情况下方程右侧都为 0. 这两个常数解称为平衡解。
![](images/Pasted%20image%2020240913083915.png)
> 在数学上，平衡解是指微分方程的解，使得方程右边等于零。换句话说，如果将 P 替换为某个特定值 p，使得 dP/dt=0，则 p 是平衡解。在这个上下文中，平衡解对应的是人口稳定的状态，即种群大小不再随时间变化的情况。

![](images/Pasted%20image%2020240913083628.png)

- 如果种群数量 P(t) 等于 0，那么就没有更多的生物可以繁殖，因为没有生物存在。所以，种群数量会保持不变。
- 如果种群数量 P(t) 等于 carrying capacity M，那么环境中的所有资源都被利用完了，没有多余的食物或其他必需品供更多生物生存。因此，种群数量也无法再增加了。

这就是为什么说 P(t)=0 和 P(t)=M 是平衡解的原因。在这些情况下，种群数量不会改变，因为没有足够的资源让种群继续增长或减少。这就像是一个天平一样，两边重量相等时，天平就不会移动。同样的道理，当种群数量等于 0 或最大承载能力时，种群数量也就不会再改变了，所以称为平衡解。

## A Model for the Motion of a Spring
![](images/Pasted%20image%2020240913091531.png)
1. **胡克定律**：弹簧受力与伸长/缩短程度的关系。

弹簧施加的恢复力与弹簧的变形程度成正比。公式如下：
![](images/Pasted%20image%2020240913084731.png)

这里的 `F_{restoring}` 是恢复力，`k` 是弹簧常数（一个衡量弹簧弹性强度的参数），`x` 是弹簧相对于自然长度的位移（拉长了多少）。负号表示恢复力的方向总是指向弹簧的自然长度方向，试图让弹簧回到原来的位置。

 2. **牛顿第二定律**：物体的加速度与作用在其上的力成正比，与物体的质量成反比。公式如下：
 ![](images/Pasted%20image%2020240913085227.png)

3. **结合胡克定律和牛顿第二定律**：如果我们把弹簧末端的物体视为只有一个重力作用（忽略空气阻力和其他摩擦力），那么物体的加速度就是由弹簧的恢复力决定的。我们可以将胡克定律带入到牛顿第二定律的公式中，得到：
![](images/Pasted%20image%2020240913085302.png)
由于物体的质量 `m` 不变，我们可以通过除以 `m` 来消除它：
![](images/Pasted%20image%2020240913085610.png)
两边同时除以 `m` 得到：
![](images/Pasted%20image%2020240913085624.png)
 **求导**：现在我们已经得到了加速度 `a` 与位置 `x` 的关系。但是，我们想要找到关于时间 `t` 的函数关系。加速度是位置的一阶导数，所以我们可以对方程两边取一次导数得到速度 `v` （一阶导数）：
 ![](images/Pasted%20image%2020240913085654.png)
 **再求导**：接下来，我们对速度 `v` 再次求导得到加速度 `a` 关于时间 `t` 的关系，也就是位置 `x` 对时间 `t` 的二阶导数：
 ![](images/Pasted%20image%2020240913085731.png)
> 在数学中，求导是一个线性的操作，也就是说，当你对一个函数进行求导的时候，只影响函数本身，而不影响其他项。在这两个步骤中，我们分别对加速度 `a` 和速度 `v` 进行求导，目的是为了找出它们各自与时间 `t` 的关系。
> 1. 在第 5 步骤中，我们对加速度 `a` 进行了一次求导，得到速度 `v`。这里，我们只是对加速度的表达式进行了求导，而没有改变右侧的 `-k/m dx/dt` 部分。这是因为右侧的 `-k/m dx/dt` 表示的是加速度 `a`，而不是速度 `v`。当我们对加速度求导时，我们只关注左侧的部分，即 `dv/dt`，而右侧的 `-k/m dx/dt` 已经是加速度的形式，不需要进一步处理。
> 2. 在第 6 步骤中，我们对速度 `v` 进行了第二次求导，得到加速度 `a` 关于时间 `t` 的关系，也就是位置 `x` 对时间 `t` 的二阶导数。这次我们仍然只对左侧的速度 `v` 进行求导，而右侧的 `-k/m dx/dt` 仍然是加速度 `a`，所以我们只需要对左侧的 `dv/dt` 进行求导，得到 `d²x/dt²`，而右侧的 `-k/m dx/dt` 不需要改变。

![](images/Pasted%20image%2020240913085318.png)
> 上方两个式子是一样的，它们都是用来描述弹簧振子运动的二阶微分方程。第一个式子是原始的表达方式，第二个式子是对第一个式子进行简化后的结果。
> 在第一个式子中，我们看到的是加速度 `a` 关于时间 `t` 的二阶导数，即位置 `x` 对时间 `t` 的二阶导数。这个方程表明，物体的加速度（位置的二阶导数）与它离平衡位置的距离成反比，而且符号相反。当我们对速度 `v` 再次求导后，得到了这个方程。
> 在第二个式子中，我们省略了中间的过程，直接给出了最终的结果。这个方程表明，物体的加速度（位置的二阶导数）与它离平衡位置的距离成反比，而且符号相反。这个方程是经过简化之后的版本，更易于理解和计算。
> 两者本质上是一样的，都表达了同一个物理现象——弹簧振子的运动规律。第一个式子包含了速度 `v` 的信息，而第二个式子则更加简洁明了，可以直接看出加速度与位置的关系。


这就是所谓的二阶微分方程，因为我们有对位置 `x` 的二次导数。这个方程告诉我们物体的加速度（位置的二阶导数）与它离平衡位置的距离成反比，而且符号相反。这意味着当物体远离平衡位置时，它会减速，最终返回到平衡位置；当物体靠近平衡位置时，它会加速，再次离开平衡位置。这样，物体就在平衡位置附近来回振动。

这表示 x 的二阶导数与 x 成正比，但具有相反的符号。我们知道两个具有此性质的函数，sin和 cos。事实上，方程 3 的所有解都可以写成某些正弦和余弦函数的组合。这并不奇怪;我们预计弹簧会围绕其平衡位置振荡，因此很自然地认为涉及三角函数。


## General Differential Equations
一般来说，微分方程含有一个或多个未知函数以及它们的导数。方程的阶数取决于最高阶导数的次数。
![](images/Pasted%20image%2020240914072046.png)
这可以理解成 y 是 x 的未知函数。

如果当 y=f (x) 及其导数代入方程时方程满足，则函数 f 称为微分方程的解,  因此 f 是方程（4）的解。
![](images/Pasted%20image%2020240914072424.png)

**求解微分方程**：当我们要求解一个微分方程时，我们的目标是找到满足方程的所有可能解。这通常不是一件容易的事情，因为没有通用的方法适用于所有的微分方程。不过，有些简单的微分方程还是很容易求解的。

考虑微分方程 `y' = x³`。我们已经知道它的解是 `y = x⁴ / 4 + C`，其中 `C` 是任意常数。这意味着无论 `x` 取什么值，只要加上一个常数 `C`，就能使方程成立。这个常数 `C` 让我们能适应不同的初始条件，比如开始时的位置或速度。


Example 1
![](images/Pasted%20image%2020240915084258.png)

在实际应用中，我们通常不只是寻找一组解（一般解），而是寻找满足额外条件（初始条件）的特殊解。例如，我们可能想知道在特定时刻 `t=t_0` 时的函数值 `y=y_0`。这就构成了一个初值问题，我们需要从所有可能的解中找出通过点 `(t_0, y_0)` 的那条曲线，以便预测系统的未来行为。

初值是指在数学和物理中，当我们研究一个动态系统时，系统在某一特定时刻的状态信息。在微积分中，特别是微分方程领域，初值通常指的是一个函数及其导数在特定时刻的值。简单来说，初值就是描述系统在开始时的情况。

举个例子，假设你在研究一辆汽车的速度随时间变化的规律，那么初值可能是汽车在 t=0 时刻的位置和速度。初值问题就是在已知这些初始状态的情况下，去预测汽车在未来的时间内的运动轨迹。