# 6.1 Â  å“ˆå¸Œè¡¨
å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰ï¼Œåˆç§°æ•£åˆ—è¡¨ï¼Œå®ƒé€šè¿‡å»ºç«‹é”®Â `key`Â ä¸å€¼Â `value`Â ä¹‹é—´çš„æ˜ å°„ï¼Œå®ç°é«˜æ•ˆçš„å…ƒç´ æŸ¥è¯¢ã€‚å…·ä½“è€Œè¨€ï¼Œå‘å“ˆå¸Œè¡¨ä¸­è¾“å…¥ä¸€ä¸ªé”®Â `key`Â ï¼Œåˆ™å¯ä»¥åœ¨Â $ğ‘‚(1)$Â æ—¶é—´å†…è·å–å¯¹åº”çš„å€¼Â `value`Â ã€‚

$f(key) = value$
![](images/Pasted%20image%2020240610152038.png)

**å“ˆå¸Œè¡¨ä¸­è¿›è¡Œå¢åˆ æŸ¥æ”¹çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯Â $ğ‘‚(1)$**

## 6.1.2 Â  å“ˆå¸Œè¡¨ç®€å•å®ç°
**ä»…ç”¨ä¸€ä¸ªæ•°ç»„æ¥å®ç°å“ˆå¸Œè¡¨**
åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå°†æ•°ç»„ä¸­çš„æ¯ä¸ªç©ºä½ç§°ä¸ºæ¡¶ï¼ˆbucketï¼‰ï¼Œæ¯ä¸ªæ¡¶å¯å­˜å‚¨ä¸€ä¸ªé”®å€¼å¯¹ã€‚å› æ­¤ï¼ŒæŸ¥è¯¢æ“ä½œå°±æ˜¯æ‰¾åˆ°Â `key`Â å¯¹åº”çš„æ¡¶ï¼Œå¹¶åœ¨æ¡¶ä¸­è·å–Â `value`

é€šè¿‡å“ˆå¸Œå‡½æ•°ï¼ˆhash functionï¼‰å®ç°åŸºäºÂ `key`Â å®šä½å¯¹åº”çš„æ¡¶

å“ˆå¸Œå‡½æ•°
> å°†ä¸€ä¸ªè¾ƒå¤§çš„è¾“å…¥ç©ºé—´æ˜ å°„åˆ°ä¸€ä¸ªè¾ƒå°çš„è¾“å‡ºç©ºé—´ã€‚
> [ä»€ä¹ˆæ˜¯å“ˆå¸Œå‡½æ•°ï¼Ÿ (nervos.org)](https://www.nervos.org/zh/knowledge-base/what_is_a_hash_function)
> [æ•£åˆ—å‡½æ•° - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦ (wikipedia.org)](https://zh.wikipedia.org/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8)

åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¾“å…¥ç©ºé—´æ˜¯æ‰€æœ‰Â `key`Â ï¼Œè¾“å‡ºç©ºé—´æ˜¯æ‰€æœ‰æ¡¶ï¼ˆæ•°ç»„ç´¢å¼•ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œè¾“å…¥ä¸€ä¸ªÂ `key`Â ï¼Œ**æˆ‘ä»¬å¯ä»¥é€šè¿‡å“ˆå¸Œå‡½æ•°å¾—åˆ°è¯¥Â `key`Â å¯¹åº”çš„é”®å€¼å¯¹åœ¨æ•°ç»„ä¸­çš„å­˜å‚¨ä½ç½®**ã€‚

è¾“å…¥ä¸€ä¸ªÂ `key`Â ï¼Œå“ˆå¸Œå‡½æ•°çš„è®¡ç®—è¿‡ç¨‹åˆ†ä¸ºä»¥ä¸‹ä¸¤æ­¥ã€‚

1. é€šè¿‡æŸç§å“ˆå¸Œç®—æ³•Â `hash()`Â è®¡ç®—å¾—åˆ°å“ˆå¸Œå€¼ã€‚
2. å°†å“ˆå¸Œå€¼å¯¹æ¡¶æ•°é‡ï¼ˆæ•°ç»„é•¿åº¦ï¼‰`capacity`Â å–æ¨¡ï¼Œä»è€Œè·å–è¯¥Â `key`Â å¯¹åº”çš„æ•°ç»„ç´¢å¼•Â `index`Â ã€‚

```
index = hash(key) % capacity
```

éšåï¼Œåˆ©ç”¨Â `index`Â åœ¨å“ˆå¸Œè¡¨ä¸­è®¿é—®å¯¹åº”çš„æ¡¶ï¼Œä»è€Œè·å–Â `value`Â ã€‚

è®¾æ•°ç»„é•¿åº¦Â `capacity = 100`ã€å“ˆå¸Œç®—æ³•Â `hash(key) = key`Â ï¼Œæ˜“å¾—å“ˆå¸Œå‡½æ•°ä¸ºÂ `key % 100`Â ã€‚å›¾ ä»¥Â `key`Â å­¦å·å’ŒÂ `value`Â å§“åä¸ºä¾‹ï¼Œå±•ç¤ºäº†å“ˆå¸Œå‡½æ•°çš„å·¥ä½œåŸç†ã€‚

![](images/Pasted%20image%2020240610153643.png)

```c
/* é”®å€¼å¯¹ int->string */
typedef struct {
    int key;
    char *val;
} Pair;

/* åŸºäºæ•°ç»„å®ç°çš„å“ˆå¸Œè¡¨ */
typedef struct {
    Pair *buckets[MAX_SIZE];
} ArrayHashMap;

/* æ„é€ å‡½æ•° */
ArrayHashMap *newArrayHashMap() {
    ArrayHashMap *hmap = malloc(sizeof(ArrayHashMap));
    for (int i=0; i < MAX_SIZE; i++) {
        hmap->buckets[i] = NULL;
    }
    return hmap;
}

/* ææ„å‡½æ•° */
void delArrayHashMap(ArrayHashMap *hmap) {
    for (int i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            free(hmap->buckets[i]->val);
            free(hmap->buckets[i]);
        }
    }
    free(hmap);
}

/* æ·»åŠ æ“ä½œ */
void put(ArrayHashMap *hmap, const int key, const char *val) {
    Pair *Pair = malloc(sizeof(Pair));
    Pair->key = key;
    Pair->val = malloc(strlen(val) + 1);
    strcpy(Pair->val, val);

    int index = hashFunc(key);
    hmap->buckets[index] = Pair;
}

/* åˆ é™¤æ“ä½œ */
void removeItem(ArrayHashMap *hmap, const int key) {
    int index = hashFunc(key);
    free(hmap->buckets[index]->val);
    free(hmap->buckets[index]);
    hmap->buckets[index] = NULL;
}

/* è·å–æ‰€æœ‰é”®å€¼å¯¹ */
void pairSet(ArrayHashMap *hmap, MapSet *set) {
    Pair *entries;
    int i = 0, index = 0;
    int total = 0;
    /* ç»Ÿè®¡æœ‰æ•ˆé”®å€¼å¯¹æ•°é‡ */
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            total++;
        }
    }
    entries = malloc(sizeof(Pair) * total);
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            entries[index].key = hmap->buckets[i]->key;
            entries[index].val = malloc(strlen(hmap->buckets[i]->val) + 1);
            strcpy(entries[index].val, hmap->buckets[i]->val);
            index++;
        }
    }
    set->set = entries;
    set->len = total;
}

/* è·å–æ‰€æœ‰é”® */
void keySet(ArrayHashMap *hmap, MapSet *set) {
    int *keys;
    int i = 0, index = 0;
    int total = 0;
    /* ç»Ÿè®¡æœ‰æ•ˆé”®å€¼å¯¹æ•°é‡ */
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            total++;
        }
    }
    keys = malloc(total * sizeof(int));
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            keys[index] = hmap->buckets[i]->key;
            index++;
        }
    }
    set->set = keys;
    set->len = total;
}

/* è·å–æ‰€æœ‰å€¼ */
void valueSet(ArrayHashMap *hmap, MapSet *set) {
    char **vals;
    int i = 0, index = 0;
    int total = 0;
    /* ç»Ÿè®¡æœ‰æ•ˆé”®å€¼å¯¹æ•°é‡ */
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            total++;
        }
    }
    vals = malloc(total * sizeof(char *));
    for (i = 0; i < MAX_SIZE; i++) {
        if (hmap->buckets[i] != NULL) {
            vals[index] = hmap->buckets[i]->val;
            index++;
        }
    }
    set->set = vals;
    set->len = total;
}

/* æ‰“å°å“ˆå¸Œè¡¨ */
void print(ArrayHashMap *hmap) {
    int i;
    MapSet set;
    pairSet(hmap, &set);
    Pair *entries = (Pair *)set.set;
    for (i = 0; i < set.len; i++) {
        printf("%d -> %s\n", entries[i].key, entries[i].val);
    }
    free(set.set);
}
```

## 6.1.3 Â  å“ˆå¸Œå†²çªä¸æ‰©å®¹
ä»æœ¬è´¨ä¸Šçœ‹ï¼Œå“ˆå¸Œå‡½æ•°çš„ä½œç”¨æ˜¯å°†æ‰€æœ‰Â `key`Â æ„æˆçš„è¾“å…¥ç©ºé—´æ˜ å°„åˆ°æ•°ç»„æ‰€æœ‰ç´¢å¼•æ„æˆçš„è¾“å‡ºç©ºé—´ï¼Œè€Œè¾“å…¥ç©ºé—´å¾€å¾€è¿œå¤§äºè¾“å‡ºç©ºé—´ã€‚å› æ­¤ï¼Œ**ç†è®ºä¸Šä¸€å®šå­˜åœ¨â€œå¤šä¸ªè¾“å…¥å¯¹åº”ç›¸åŒè¾“å‡ºâ€çš„æƒ…å†µ**ã€‚

```
12836 % 100 = 36
20336 % 100 = 36
```

å“ˆå¸Œå†²çªï¼ˆhash collisionï¼‰ã€‚

![](images/Pasted%20image%2020240610154837.png)

**é€šè¿‡æ‰©å®¹å“ˆå¸Œè¡¨æ¥å‡å°‘å“ˆå¸Œå†²çª**ã€‚

![](images/Pasted%20image%2020240610154901.png)

è´Ÿè½½å› å­ï¼ˆload factorï¼‰æ˜¯å“ˆå¸Œè¡¨çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼Œå…¶å®šä¹‰ä¸ºå“ˆå¸Œè¡¨çš„å…ƒç´ æ•°é‡é™¤ä»¥æ¡¶æ•°é‡ï¼Œç”¨äºè¡¡é‡å“ˆå¸Œå†²çªçš„ä¸¥é‡ç¨‹åº¦ï¼Œ**ä¹Ÿå¸¸ä½œä¸ºå“ˆå¸Œè¡¨æ‰©å®¹çš„è§¦å‘æ¡ä»¶**ã€‚ä¾‹å¦‚åœ¨ Java ä¸­ï¼Œå½“è´Ÿè½½å› å­è¶…è¿‡Â 0.75Â æ—¶ï¼Œç³»ç»Ÿä¼šå°†å“ˆå¸Œè¡¨æ‰©å®¹è‡³åŸå…ˆçš„Â 2Â å€ã€‚